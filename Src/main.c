/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stdint.h>
#include <stdbool.h>
#include <math.h>
#include "stm32f1xx.h"


#define STEPPER_MOTOR_TASK_FREQUENCY 100
#define STEPPER_MOTOR_TASK_PERIOD (1000/STEPPER_MOTOR_TASK_FREQUENCY)

#define STEPPER_MOTOR_MAX_FREQ_HZ (MICRO_STE * 1000)
#define STEPPER_MOTOR_MIN_FREQ_HZ 1


#define STEPPER_MOTOR_MAX_SPEED_STEPS_PER_SEC STEPPER_MOTOR_MAX_FREQ_HZ
#define STEPPER_MOTOR_MIN_SPEED_STEPS_PER_SEC (STEPPER_MOTOR_MAX_SPEED_STEPS_PER_SEC / 100)

#define STEP_PER_REVOLUTION 200
#define MICRO_STEP 32

#define STEPS_TO_STOP 20
#define MINIMUM_SPEED 1
#define MAXIMUM_SPEED 100
#define ACEEL 10
#define DECEL -10


struct speed_profile_s
{
	uint32_t target_speed;
	uint32_t accel;
	uint32_t decel;//to musi byc ustawiane na minus
	uint32_t minimum_speed;
};

struct ramp_s
{
	uint32_t steps_to_stop;//tutaj doswiadczalnie wybierz sobie i wteyd masz po porstu niewielka ilosc krokow z minimalna prekdoscia
	uint32_t steps_to_accel;
	uint32_t steps_to_decel;
	uint32_t steps_with_max_speed;
};

struct stepper_s
{
	struct speed_profile_s profile;
	struct ramp_s ramp;

	volatile uint32_t step_counter;//aktualna wartosc krokow
	uint32_t steps_to_count;

	uint32_t actual_speed;
	bool direction;

	uint32_t target_speed_achived;
};

struct stepper_s motor;//obiekt globalny i chuj


void TIM3_interrupt_Handler(void)
{
	if(TIM3->SR & TIM_SR_UIF)// sprwadzenie czy flaga przerwania jest ustawiona
	{
		TIM3->SR &= ~TIM_SR_UIF;//czyszcznie flagi przerwania

	}
}


void pwm_set(uint16_t wypelnienie, uint16_t czestotliowsc, uint8_t kanal)//ustawnie odpowiendich pinow
//czyli albo PA6 = 1 PA7 = 2 PB0 = 3 PB1 = 4
{
	// Włączenie zegara dla portów GPIOA i GPIOB
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN | RCC_APB2ENR_IOPBEN;

	// Ustawienie odpowiedniego pinu jako wyjście funkcji alternatywnej push-pull 50 MHz
	GPIO_TypeDef* port;
	uint16_t pin;

	switch (kanal) {
		case 1:
			port = GPIOA; // PA6
			pin = 6;
			break;
		case 2:
			port = GPIOA; // PA7
			pin = 7;
			break;
		case 3:
			port = GPIOB; // PB0
			pin = 0;
			break;
		case 4:
			port = GPIOB; // PB1
			pin = 1;
			break;
		default:
			return; // Niepoprawny numer kanału, nie wykonuj nic
	}

	// Ustawienie pinu jako wyjście funkcji alternatywnej push-pull 50 MHz
	if (port == GPIOA) {
	    port->CRL &= ~(0xF << (pin * 4)); // Wyzerowanie ustawień dla pinu
	    port->CRL |= (0x2 << (pin * 4)) | (0x3 << (pin * 4)); // CNF i MODE
	} else if (port == GPIOB) {
	    port->CRL &= ~(0xF << (pin * 4)); // Wyzerowanie ustawień dla pinu
	    port->CRL |= (0x2 << (pin * 4)) | (0x3 << (pin * 4)); // CNF i MODE
	}


	// Włączenie zegara dla TIM3
	RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;

	// Ustawienie TIM3 na wybranym kanale jako wyjście PWM (tryb PWM1)
	if (kanal == 1) {
		TIM3->CCMR1 |= TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1; // Tryb PWM1 dla kanału 1
		TIM3->CCER |= TIM_CCER_CC1E;                          // Włączenie kanału 1 TIM3
	} else if (kanal == 2) {
		TIM3->CCMR1 |= TIM_CCMR1_OC2M_2 | TIM_CCMR1_OC2M_1; // Tryb PWM1 dla kanału 2
		TIM3->CCER |= TIM_CCER_CC2E;                          // Włączenie kanału 2 TIM3
	} else if (kanal == 3) {
		TIM3->CCMR2 |= TIM_CCMR2_OC3M_2 | TIM_CCMR2_OC3M_1; // Tryb PWM1 dla kanału 3
		TIM3->CCER |= TIM_CCER_CC3E;                          // Włączenie kanału 3 TIM3
	} else if (kanal == 4) {
		TIM3->CCMR2 |= TIM_CCMR2_OC4M_2 | TIM_CCMR2_OC4M_1; // Tryb PWM1 dla kanału 4
		TIM3->CCER |= TIM_CCER_CC4E;                          // Włączenie kanału 4 TIM3
	}

	// Ustawienie preskalera i wartości ARR dla częstotliwości PWM
	TIM3->PSC = 71999; // Prescaler dla 1 MHz (przy zegarze 72 MHz)
	TIM3->ARR = czestotliowsc; // Ustawienie ARR dla zadanej częstotliwości

	// Ustawienie wypełnienia PWM (przykład 50%)
	uint16_t WYPELNIENIE = wypelnienie * (czestotliowsc + 1) / 100; // Obliczanie wypełnienia
	if (kanal == 1) {
		TIM3->CCR1 = WYPELNIENIE; // Wypełnienie na kanale TIM3_CH1
	} else if (kanal == 2) {
		TIM3->CCR2 = WYPELNIENIE; // Wypełnienie na kanale TIM3_CH2
	} else if (kanal == 3) {
		TIM3->CCR3 = WYPELNIENIE; // Wypełnienie na kanale TIM3_CH3
	} else if (kanal == 4) {
		TIM3->CCR4 = WYPELNIENIE; // Wypełnienie na kanale TIM3_CH4
	}

	// Włączenie przerwania od aktualizacji (Update Interrupt Enable)
	TIM3->DIER |= TIM_DIER_UIE;

	// Włączenie timera TIM3
	TIM3->CR1 |= TIM_CR1_CEN; // Włączenie timera

	// Włączenie NVIC dla TIM3
	NVIC_EnableIRQ(TIM3_IRQn); // Włączenie przerwań dla TIM3
	NVIC_SetPriority(TIM3_IRQn, 1); // Ustawienie priorytetu

}

//hsack_fbi().execute()
//		motor.rotate.move()

void direction_pin_set(uint8_t pin)//na razie ustawiam sobie pin A9 jako zwykle ustawianie
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;

	if(pin >= 8 && pin <= 15)
	{
		GPIOA->CRH |= (0x01 << (pin * 4 + GPIO_CRH_MODE_Pos));
	}
}

void left_rotation(uint8_t pin)
{
	if(pin >= 8 && pin <= 15)
	{
		GPIOA->BSRR = (1<<pin);
	}
}

void right_rotation(uint8_t pin)
{
	if(pin >= 8 && pin <= 15)
	{
		GPIOA->BRR = (1<<pin);
	}
}

void speed_profile_init(struct speed_profile_s *profile, uint32_t target_speed, uint32_t accel, uint32_t decel, uint32_t minimum_speed)
{
	profile->target_speed = target_speed;
	profile->accel = accel;
	profile->decel = decel;
	profile->minimum_speed = minimum_speed;
}

void stepper_set_angle(struct stepper_s *motor,uint32_t angle)//funkcja do kofiguracji ruchu i dlugosci korkow poszczegolnych faz ruchu
{
	motor->ramp.steps_to_stop = STEPS_TO_STOP;

	if(angle > 0)
	{
		motor->direction = true;
	}
	else
	{
		motor->direction = false;
	}

	speed_profile_init( &motor->profile, MAXIMUM_SPEED, ACEEL, DECEL, MINIMUM_SPEED);
	motor->step_counter = 0;
	motor->steps_to_count = angle * (STEP_PER_REVOLUTION * MICRO_STEP) / 360;//dobra mamy ilosc krokow
	motor->ramp.steps_to_accel = (motor->profile.target_speed * motor->profile.target_speed) / (2 * motor->profile.accel);
	motor->ramp.steps_to_decel = ((motor->profile.minimum_speed - motor->profile.target_speed)*(motor->profile.minimum_speed - motor->profile.target_speed)) / (2 * motor->profile.decel);

	if((motor->steps_to_count - (motor->ramp.steps_to_accel + motor->ramp.steps_to_decel + motor->ramp.steps_to_stop)) >= 0 )
	{
		//tutaj mozemy sie rozpedziec do maksymalnej predkosci weic jest g
		motor->ramp.steps_with_max_speed = motor->steps_to_count - (motor->ramp.steps_to_accel + motor->ramp.steps_to_decel + motor->ramp.steps_to_stop);
	}
	else
	{
		//tutaj nie rozpedzimy sie calkowicie zatem ruch trojkatny
		motor->profile.target_speed = sqrt(motor->steps_to_count / ((1 / (2 * motor->profile.accel)) - (1 / (2 * motor->profile.decel))));
		motor->ramp.steps_to_accel = (motor->profile.target_speed * motor->profile.target_speed) / (2 * motor->profile.accel);
		motor->ramp.steps_to_decel = - (motor->profile.target_speed * motor->profile.target_speed) / (2 * motor->profile.decel);
		motor->ramp.steps_with_max_speed = 0;//dobra nie ma zatem ruchu z maksymalna predkoscia
	}

}

void speed_set(struct stepper_s *motor)
{
	if(motor->ramp.steps_with_max_speed != 0) //ruch trapezoidalny
	{
		if(motor->step_counter <= motor->ramp.steps_to_accel)//ruch przyspieszania
		{
			//zwieksz czestotliowisc
			//wykonaj krok
		}
		else if(motor->step_counter <= (motor->ramp.steps_to_accel + motor->ramp.steps_with_max_speed))//ruch z pelna predkoscia
		{

		}
		else if(motor->step_counter <= (motor->ramp.steps_to_accel + motor->ramp.steps_with_max_speed + motor->ramp.steps_to_decel))//ruch hamujacy
		{

		}
		else if(motor->step_counter <= (motor->steps_to_count - motor->ramp.steps_to_stop))//ruch dojezdzajacy BABYSTEPPING
		{

		}
	}
	else
	{
		if(motor->step_counter <= motor->ramp.steps_to_accel)//rucg przyspieszajacy
		{

		}
		else if(motor->step_counter <= motor->ramp.steps_to_accel + motor->ramp.steps_to_decel)//ruch hamuijacy
		{

		}
		else if(motor->step_counter <= motor->steps_to_count - motor->ramp.steps_to_stop)//ruch dojezdzajacy BABYSTEPPING
		{

		}
	}
}

int main()
{


}
